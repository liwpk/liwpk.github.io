<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"/><meta name="og:site_name" content="MyBlog"/><link rel="canonical" href="https://your-website-url.com/posts/TG"/><meta name="twitter:url" content="https://your-website-url.com/posts/TG"/><meta name="og:url" content="https://your-website-url.com/posts/TG"/><title>Telegram | MyBlog</title><meta name="twitter:title" content="Telegram | MyBlog"/><meta name="og:title" content="Telegram | MyBlog"/><meta name="description" content="some about TG."/><meta name="twitter:description" content="some about TG."/><meta name="og:description" content="some about TG."/><meta name="twitter:card" content="summary"/><link rel="stylesheet" href="/styles.css" type="text/css"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="shortcut icon" href="/images/favicon.png" type="image/png"/><link rel="alternate" href="/feed.rss" type="application/rss+xml" title="Subscribe to MyBlog"/></head><body class="item-page"><header><div class="wrapper"><a href="/" class="site-name">MyBlog</a><nav><ul><li><a href="/posts" class="selected">My posts</a></li><li><a href="/about">About</a></li></ul></nav></div></header><div class="wrapper"><article><div class="content"><h1>Telegram</h1><h2>网络连接模块:</h2><p>1,ping网络地址<br>2,通过秘钥交换: 生成一个authkey,以后数据解密就通过这个authkey来做<br><code></code>`java 三个协议生成authkey</p><pre><code>心跳包: updatestate

salt有效期:防重放攻击,messageid在salt时间内才能算有效包

serverTime:获取时机网络连接上之后,更新本地servertime,因为messageid通过servertime生成,所以不能用本地time,可能被篡改

## ip地址选择

内置多个ip(主ip:服务端下发消息的IP, mediaIP:需要进行数据下载会连接此IP,下载后会立即断开,服务端不会通过此ip下发消息,cdn:没有使用到):选择最优ip进行socket通信,getconfig下发服务端配置的地址,然后进行重新择优选择连接,authkey不会变


地址切换: 如果连接超时,30s没收到回包,内置地址服务器通过http拉取,服务器配置的地址,getconfig拉下来的地址进行连接,选择最先连接上的地址

## ack机制

ack: 根据下发包的sn是否是奇数来定义,把相应的messageid添加到本地ack队列,下次上发数据会带上这串messageid上发给服务端,服务端就知道我们收到这些消息  
quickAck: 消息快速确认机制,用于一般的文本消息,快速更新回话中的消息状态:已发送


## 消息上发

数据包的组装:MTMessage通过协议组装成一段数据流  
本地配置:container大小:每段上发的数据有大小限制,默认 1M?  
本地生成一个messageid(由servertime生成,用于上发数据的标识,下发数据的时候也会带下来,通过该messageid定位消息对象,回调到数据处理层)

如果某段时间需要上发多天数据就会通过container组装消息流,组装成功需要通过authkey加密上发服务端,并把消息服务对象添加到消息发送队列  
服务端响应的数据: 通过messageid找到对应的消息服务对象,该对象回调方法通过rpc协议解析结构体,回传到数据层处理


## 消息同步机制, getdifference(pts,timestap):收取中状态
本地维护一个pts状态,
一个channel一个pts状态,
 收到的数据会通过pts从小到大排序出一个updates数组
 pts检验 本地pts = 下发的pts - 下发的ptscoun即为合法的update
 commit更新本地的状态state(pts,qts),以及本地的数据库

 如果遇到有校验不成功的pts则等2s去继续getdifference(等两秒估计是为了看看是否还有其他没有下发的update)

 校验数据: 如果拉到channel的update也是通过channel的摘选出是否需要getchanneldifference的

校验本地是否存在消息相关的dialogid,message,peer
eg:消息转发forwordmessageid:检查是否存在对应的消息,没有的话就getmessage拉取该条消息
    message对应的author,如果不存在peer信息,则getpeer拉取消息?


## app启动:
加载用户目录
初始化本地存储路径,通过全局表寻找当前用户路径
如果不存在,则随机生成accountid作为当前用户路径
如果存在,加载该路径下的用户数据

数据库升级校验,内置版本号与本地数据库版本号比较
如果内置&gt;本地存储,执行数据库升级事务操作,并且当前状态为updating(相关界面展示)
如果相等,加载数据库数据,进入UNAuthorized或者auth状态

getconfig拉取配置信息:ip地址列表,是否收集日志等配置(24小时循环拉取)

sticker与gif代码没用到

## 刚刚登录:
getstate:初始化状态pts -&gt; getdifference  
getdialogs  
getcontacts  
....


## 登录之后:首先

拉取消息:根据本地timestamp与pts getdifference拉取消息  

1,differenceToolong: 所有带pts下发的update都应该reset  
getpeerdialogs重置会话
newtopmessage&gt;localtopmessage  
则创建hole(newtopmessage - localtopmessage),也可以删除所有会话删除所有消息消息(tg采用第一种)  
getcontacts重置本地联系人列表

2,走正常pts校验逻辑  
3,如果包含updatechanneltoolong, getchanneldifference-&gt;拉取channel相关update更新本地数据

## channel大群与普通群的区别
channel  
1,所有成员视图一致,server端维护一个信箱,保证消息的一致性
只有撤回消息,没有为自己删除消息    
普通小群  

不同成员有不同的信箱,分角色,不同角色可能看到的视图不一致
eg:删除自己的消息和删除所有人的消息

## 小群转大群
人数达到一定数量之后,服务端主动推送update大群变更rpc, 加载大群的时候有associatepeer,把以前群聊隐藏,创建channel的dialog   
加载消息先拿取associatepeer里面的消息,再获取channel的消息  
排序: messageindex里面的namespace:group&gt;channel,保证小群消息排在最前面

## listview:
目前只在使用阶段,里面diff算法比较麻烦,没仔细研究
entry(重写diff方法,用于更新UI) -&gt; item -&gt; listNode

## display:
basecontroller: 控制器基类,hook了系统的viewdidapper,viewdidload等方法,可以设置横竖屏操作等  
present与push自己写了一套动画实现,基本和系统的一致

视图布局更新: 
处理了window的layoutsubview方法,调用rootcontroller的刷新,遍历调用每个子控制器
containerLayoutUpdated:

整个视图层级
notificationcontroller,用于消息通知显示
overlayermediacontroller,用于展现浮窗,例如自拍视频的播放
底部则为rootviewcontroller:navigationcontroller



## 图片上传处理
文件名:
本地生成一个随机fileId,作为存储路径  
分片上传,每片有大小限制  
上传一张图片后,会存储对应byte的MD5值,下次再次选择这张图片的时候,会通过这个md5值查找对应得media  
</code></pre><p>java let md5 = IncrementalMD5() fileData.withUnsafeBytes { (bytes: UnsafePointer<Int8>) -> Void in
        var offset = 0
        let bufferSize = 32 * 1024

        while offset < fileData.count {
            let partSize = min(fileData.count - offset, bufferSize)
            md5.update(bytes.advanced(by: offset), count: Int32(partSize))
            offset += bufferSize
        }
    }

    let res = md5.complete()

    //获取
    func cachedSentMediaReference(postbox: Postbox, key: CachedSentMediaReferenceKey) -> Signal<Media?, NoError> {
        return postbox.transaction { transaction -> Media? in
            return transaction.retrieveItemCacheEntry(id: ItemCacheEntryId(collectionId: Namespaces.CachedItemCollection.cachedSentMediaReferences, key: key.key)) as? Media
        }
    }
    //存储
    func storeCachedSentMediaReference(transaction: Transaction, key: CachedSentMediaReferenceKey, media: Media) {
        transaction.putItemCacheEntry(id: ItemCacheEntryId(collectionId: Namespaces.CachedItemCollection.cachedSentMediaReferences, key: key.key), entry: media, collectionSpec: cachedSentMediaCollectionSpec)
    }

    //上传方法调用
    let (contentUploadSignal, contentType) = messageContentToUpload
```

如果能找到则直接sendMedia发送以前媒体id  
没找到则存储缩略图和大图到本地,然后上传大图数据到server  
server端返回有数据包含大图,缩略图两个id,根据两个id名字生成文件,本地之前存储的大图和缩略图link到对应文件 
uploadfile分片上传文件 -> sendmedia

sendmutilMedia,如果上传多张图片,则先分片上传没张图,传完之后sendmutilMedia包含说有图片的media,
服务端返回一个groupID(多图组装消息时候使用)

## 表结构:
 > messagehistoryTable

 key: 20字节
 ```java
    private func key(_ index: MessageIndex, key: ValueBoxKey = ValueBoxKey(length: 8 + 4 + 4 + 4)) -> ValueBoxKey {
        key.setInt64(0, value: index.id.peerId.toInt64())
        key.setInt32(8, value: index.timestamp)
        key.setInt32(8 + 4, value: index.id.namespace)
        key.setInt32(8 + 4 + 4, value: index.id.id)
        return key
    }
 ```
 value: message消息实体

 > messageIndexTable

 key: 16个字节
 ```java
     private func key(_ id: MessageId) -> ValueBoxKey {
        let key = ValueBoxKey(length: 8 + 4 + 4)
        key.setInt64(0, value: id.peerId.toInt64())
        key.setInt32(8, value: id.namespace)
        key.setInt32(8 + 4, value: id.id)
        return key
    }
 ```
 value:
 ```java
        // message: 5字节
        var flags: Int8 = HistoryEntryTypeMessage
        if message.flags.contains(.Incoming) {
            flags |= HistoryEntryMessageFlagIncoming
        }
        var timestamp: Int32 = index.timestamp
        value.write(&flags, offset: 0, length: 1)
        value.write(&timestamp, offset: 0, length: 4)

        //hole: 19字节
        var flags: Int8 = HistoryEntryTypeHole
        var timestamp: Int32 = hole.maxIndex.timestamp
        var min: Int32 = hole.min
        var tags: UInt32 = hole.tags
        value.write(&flags, offset: 0, length: 1)
        value.write(&timestamp, offset: 0, length: 4)
        var stableId: UInt32 = hole.stableId
        value.write(&stableId, offset: 0, length: 4)
        value.write(&min, offset: 0, length: 4)
        value.write(&tags, offset: 0, length: 4)
 ```
 > dialogTable

 key:
 ```java
    private func key(_ id: PeerId) -> ValueBoxKey {
    self.sharedKey.setInt64(0, value: id.toInt64())
    return self.sharedKey
}
 ```
 value:  
 .idBased(maxIncomingReadId: MessageId.Id, maxKnownId: MessageId.Id, count: Int32, date: Int32)


 > fullTextTable
 ```java
 //collectionId:回话id查找
 //itemId:消息id
 //contents:消息文本
 //tags:根据消息类型查找
 //authorId:根据用户查找
 self.database.execute("CREATE VIRTUAL TABLE ft\(table.id) USING fts5(collectionId, itemId, contents, tags, authorId)")
 ```

## 小tag
### 未读数
 服务端能实现精确控制,客户端存在精度问题,对于消息很多的情况,本地计算已读消息可能会有消息未拉下来的情况,计算有误差
### 消息发送
有张单独的unsendMessage表:存储当前发送中的消息messageIndex,commit提交之前会sendmessage
如果发送过程中杀死app,下次进来会读取unsendMessageTable,找到对应id继续发送,直到server响应为止(失败或者成功),删除数据
</p></div><span>Tagged with: </span><ul class="tag-list"><li><a href="/tags/tg">TG</a></li><li><a href="/tags/article">article</a></li></ul></article></div><footer><p>Generated using <a href="https://github.com/johnsundell/publish">Publish</a></p><p><a href="/feed.rss">RSS feed</a></p></footer></body></html>